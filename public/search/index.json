[{"content":"XXL-JOB\rXXL-JOB介绍\rXXL-JOB是一个轻量级分布式任务调度平台，其核心设计是开发迅速、学习简单、轻量级、易扩展，现已开放源代码并接入多家公司线上产品线，开箱即用\n官网：https://www.xuxueli.com/xxl-job/\nXXL-JOB主要由调度中心、执行器、任务\n调度中心 负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码 主要职责为执行器管理、任务管理、监控运维、日志管理等 任务执行器 负责接收调度请求并执行任务逻辑 主要职责是注册服务、任务执行服务（接收到任务后会放入线程池中的任务队列）、执行结果上报、日志服务等 任务 负责执行具体的业务逻辑 调度中心与执行器之间的工作流程如下 执行流程\n任务执行器根据配置的调度中心的地址，自动注册到调度中心 达到任务出发条件，调度中心下发任务 执行器基于线程池执行任务，并把执行结果放入内存队列、把执行日志写入日志文件中 执行器消费内存队列中的执行结果，主动上报给调度中心 当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情 利用docker搭建XXL-JOB\rdocket命令\rdocker search xxl-job 查看xxl-job docker pull xuxueli/xxl-job-admin:2.4.0 拉取 2.4.0版本 docker run -d \\ -p 8088:8088 \\ -v /tool/xxl-job/logs:/data/applogs \\ -v /tool/xxl-job/application.properties:/xxl-job/xxl-job-admin/src/main/resources/application.properties \\ -e SPRING_DATASOURCE_URL=\u0026#39;jdbc:mysql://192.168.75.130:3306/xxl_job?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;autoReconnect=true\u0026amp;serverTimezone=Asia/Shanghai\u0026#39; \\ -e SPRING_DATASOURCE_USERNAME=root \\ -e SPRING_DATASOURCE_PASSWORD=123456 \\ xuxueli/xxl-job-admin:2.4.0 创建xxl_job数据库\rCREATE database if NOT EXISTS `xxl_job` default character set utf8mb4 collate utf8mb4_unicode_ci; use `xxl_job`; SET NAMES utf8mb4; CREATE TABLE `xxl_job_info` ( `id` int(11) NOT NULL AUTO_INCREMENT, `job_group` int(11) NOT NULL COMMENT \u0026#39;执行器主键ID\u0026#39;, `job_desc` varchar(255) NOT NULL, `add_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, `author` varchar(64) DEFAULT NULL COMMENT \u0026#39;作者\u0026#39;, `alarm_email` varchar(255) DEFAULT NULL COMMENT \u0026#39;报警邮件\u0026#39;, `schedule_type` varchar(50) NOT NULL DEFAULT \u0026#39;NONE\u0026#39; COMMENT \u0026#39;调度类型\u0026#39;, `schedule_conf` varchar(128) DEFAULT NULL COMMENT \u0026#39;调度配置，值含义取决于调度类型\u0026#39;, `misfire_strategy` varchar(50) NOT NULL DEFAULT \u0026#39;DO_NOTHING\u0026#39; COMMENT \u0026#39;调度过期策略\u0026#39;, `executor_route_strategy` varchar(50) DEFAULT NULL COMMENT \u0026#39;执行器路由策略\u0026#39;, `executor_handler` varchar(255) DEFAULT NULL COMMENT \u0026#39;执行器任务handler\u0026#39;, `executor_param` varchar(512) DEFAULT NULL COMMENT \u0026#39;执行器任务参数\u0026#39;, `executor_block_strategy` varchar(50) DEFAULT NULL COMMENT \u0026#39;阻塞处理策略\u0026#39;, `executor_timeout` int(11) NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;任务执行超时时间，单位秒\u0026#39;, `executor_fail_retry_count` int(11) NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;失败重试次数\u0026#39;, `glue_type` varchar(50) NOT NULL COMMENT \u0026#39;GLUE类型\u0026#39;, `glue_source` mediumtext COMMENT \u0026#39;GLUE源代码\u0026#39;, `glue_remark` varchar(128) DEFAULT NULL COMMENT \u0026#39;GLUE备注\u0026#39;, `glue_updatetime` datetime DEFAULT NULL COMMENT \u0026#39;GLUE更新时间\u0026#39;, `child_jobid` varchar(255) DEFAULT NULL COMMENT \u0026#39;子任务ID，多个逗号分隔\u0026#39;, `trigger_status` tinyint(4) NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;调度状态：0-停止，1-运行\u0026#39;, `trigger_last_time` bigint(13) NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;上次调度时间\u0026#39;, `trigger_next_time` bigint(13) NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;下次调度时间\u0026#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; CREATE TABLE `xxl_job_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `job_group` int(11) NOT NULL COMMENT \u0026#39;执行器主键ID\u0026#39;, `job_id` int(11) NOT NULL COMMENT \u0026#39;任务，主键ID\u0026#39;, `executor_address` varchar(255) DEFAULT NULL COMMENT \u0026#39;执行器地址，本次执行的地址\u0026#39;, `executor_handler` varchar(255) DEFAULT NULL COMMENT \u0026#39;执行器任务handler\u0026#39;, `executor_param` varchar(512) DEFAULT NULL COMMENT \u0026#39;执行器任务参数\u0026#39;, `executor_sharding_param` varchar(20) DEFAULT NULL COMMENT \u0026#39;执行器任务分片参数，格式如 1/2\u0026#39;, `executor_fail_retry_count` int(11) NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;失败重试次数\u0026#39;, `trigger_time` datetime DEFAULT NULL COMMENT \u0026#39;调度-时间\u0026#39;, `trigger_code` int(11) NOT NULL COMMENT \u0026#39;调度-结果\u0026#39;, `trigger_msg` text COMMENT \u0026#39;调度-日志\u0026#39;, `handle_time` datetime DEFAULT NULL COMMENT \u0026#39;执行-时间\u0026#39;, `handle_code` int(11) NOT NULL COMMENT \u0026#39;执行-状态\u0026#39;, `handle_msg` text COMMENT \u0026#39;执行-日志\u0026#39;, `alarm_status` tinyint(4) NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;告警状态：0-默认、1-无需告警、2-告警成功、3-告警失败\u0026#39;, PRIMARY KEY (`id`), KEY `I_trigger_time` (`trigger_time`), KEY `I_handle_code` (`handle_code`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; CREATE TABLE `xxl_job_log_report` ( `id` int(11) NOT NULL AUTO_INCREMENT, `trigger_day` datetime DEFAULT NULL COMMENT \u0026#39;调度-时间\u0026#39;, `running_count` int(11) NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;运行中-日志数量\u0026#39;, `suc_count` int(11) NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;执行成功-日志数量\u0026#39;, `fail_count` int(11) NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;执行失败-日志数量\u0026#39;, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `i_trigger_day` (`trigger_day`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; CREATE TABLE `xxl_job_logglue` ( `id` int(11) NOT NULL AUTO_INCREMENT, `job_id` int(11) NOT NULL COMMENT \u0026#39;任务，主键ID\u0026#39;, `glue_type` varchar(50) DEFAULT NULL COMMENT \u0026#39;GLUE类型\u0026#39;, `glue_source` mediumtext COMMENT \u0026#39;GLUE源代码\u0026#39;, `glue_remark` varchar(128) NOT NULL COMMENT \u0026#39;GLUE备注\u0026#39;, `add_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; CREATE TABLE `xxl_job_registry` ( `id` int(11) NOT NULL AUTO_INCREMENT, `registry_group` varchar(50) NOT NULL, `registry_key` varchar(255) NOT NULL, `registry_value` varchar(255) NOT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `i_g_k_v` (`registry_group`,`registry_key`,`registry_value`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; CREATE TABLE `xxl_job_group` ( `id` int(11) NOT NULL AUTO_INCREMENT, `app_name` varchar(64) NOT NULL COMMENT \u0026#39;执行器AppName\u0026#39;, `title` varchar(12) NOT NULL COMMENT \u0026#39;执行器名称\u0026#39;, `address_type` tinyint(4) NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;执行器地址类型：0=自动注册、1=手动录入\u0026#39;, `address_list` text COMMENT \u0026#39;执行器地址列表，多地址逗号分隔\u0026#39;, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; CREATE TABLE `xxl_job_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(50) NOT NULL COMMENT \u0026#39;账号\u0026#39;, `password` varchar(50) NOT NULL COMMENT \u0026#39;密码\u0026#39;, `role` tinyint(4) NOT NULL COMMENT \u0026#39;角色：0-普通用户、1-管理员\u0026#39;, `permission` varchar(255) DEFAULT NULL COMMENT \u0026#39;权限：执行器ID列表，多个逗号分割\u0026#39;, PRIMARY KEY (`id`), UNIQUE KEY `i_username` (`username`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; CREATE TABLE `xxl_job_lock` ( `lock_name` varchar(50) NOT NULL COMMENT \u0026#39;锁名称\u0026#39;, PRIMARY KEY (`lock_name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; INSERT INTO `xxl_job_group`(`id`, `app_name`, `title`, `address_type`, `address_list`, `update_time`) VALUES (1, \u0026#39;xxl-job-executor-sample\u0026#39;, \u0026#39;示例执行器\u0026#39;, 0, NULL, \u0026#39;2018-11-03 22:21:31\u0026#39; ); INSERT INTO `xxl_job_info`(`id`, `job_group`, `job_desc`, `add_time`, `update_time`, `author`, `alarm_email`, `schedule_type`, `schedule_conf`, `misfire_strategy`, `executor_route_strategy`, `executor_handler`, `executor_param`, `executor_block_strategy`, `executor_timeout`, `executor_fail_retry_count`, `glue_type`, `glue_source`, `glue_remark`, `glue_updatetime`, `child_jobid`) VALUES (1, 1, \u0026#39;测试任务1\u0026#39;, \u0026#39;2018-11-03 22:21:31\u0026#39;, \u0026#39;2018-11-03 22:21:31\u0026#39;, \u0026#39;XXL\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;CRON\u0026#39;, \u0026#39;0 0 0 * * ? *\u0026#39;, \u0026#39;DO_NOTHING\u0026#39;, \u0026#39;FIRST\u0026#39;, \u0026#39;demoJobHandler\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;SERIAL_EXECUTION\u0026#39;, 0, 0, \u0026#39;BEAN\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;GLUE代码初始化\u0026#39;, \u0026#39;2018-11-03 22:21:31\u0026#39;, \u0026#39;\u0026#39;); INSERT INTO `xxl_job_user`(`id`, `username`, `password`, `role`, `permission`) VALUES (1, \u0026#39;admin\u0026#39;, \u0026#39;e10adc3949ba59abbe56e057f20f883e\u0026#39;, 1, NULL); INSERT INTO `xxl_job_lock` ( `lock_name`) VALUES ( \u0026#39;schedule_lock\u0026#39;); 网站登录\r根据数据库脚本创建数据库，修改数据库连接信息和端口，启动xxl-job-admin，访问http://local:18088/xxl-job-admin/\n账号密码：admin/123456 java连接xxl-job\r添加依赖\r（父工程中完成了版本控制，这里的版本是2.4.0）\nXML \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.xuxueli\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xxl-job-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yaml文件添加\rxxl: job: admin: addresses: http://...........:8088/xxl-job-admin/ #... 更换服务器地址 executor: appname: media-process-service #执行器名字 address: ip: port: 9999 logpath: /data/applogs/xxl-job-jobhandler logretentiondays: 30 accessToken: default_token 配置xxl-job的执行器\r将示例工程下的配置类拷贝到media-service工程下，该类中的属性就是获取配置文件中的配置得到的，同时提供了一个执行器的Bean JAVA @Configuration public class XxlJobConfig { private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value(\u0026#34;${xxl.job.admin.addresses}\u0026#34;) private String adminAddresses; @Value(\u0026#34;${xxl.job.accessToken}\u0026#34;) private String accessToken; @Value(\u0026#34;${xxl.job.executor.appname}\u0026#34;) private String appname; @Value(\u0026#34;${xxl.job.executor.address}\u0026#34;) private String address; @Value(\u0026#34;${xxl.job.executor.ip}\u0026#34;) private String ip; @Value(\u0026#34;${xxl.job.executor.port}\u0026#34;) private int port; @Value(\u0026#34;${xxl.job.executor.logpath}\u0026#34;) private String logPath; @Value(\u0026#34;${xxl.job.executor.logretentiondays}\u0026#34;) private int logRetentionDays; @Bean public XxlJobSpringExecutor xxlJobExecutor() { logger.info(\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; xxl-job config init.\u0026#34;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setAddress(address); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; } /** * 针对多网卡、容器内部署等情况，可借助 \u0026#34;spring-cloud-commons\u0026#34; 提供的 \u0026#34;InetUtils\u0026#34; 组件灵活定制注册IP； * * 1、引入依赖： * \u0026lt;dependency\u0026gt; * \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; * \u0026lt;artifactId\u0026gt;spring-cloud-commons\u0026lt;/artifactId\u0026gt; * \u0026lt;version\u0026gt;${version}\u0026lt;/version\u0026gt; * \u0026lt;/dependency\u0026gt; * * 2、配置文件，或者容器启动变量 * spring.cloud.inetutils.preferred-networks: \u0026#39;xxx.xxx.xxx.\u0026#39; * * 3、获取IP * String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress(); */ } 进入调度中心，添加执行器\r重启，可以看到执行器在调入中心注册成功\r执行任务\r下面编写任务，任务类的编写方法参考示例工程 JAVA package com.xxl.job.executor.service.jobhandler; import com.xxl.job.core.context.XxlJobHelper; import com.xxl.job.core.handler.annotation.XxlJob; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import java.io.BufferedInputStream; import java.io.BufferedReader; import java.io.DataOutputStream; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; import java.util.Arrays; import java.util.concurrent.TimeUnit; /** * XxlJob开发示例（Bean模式） * * 开发步骤： * 1、任务开发：在Spring Bean实例中，开发Job方法； * 2、注解配置：为Job方法添加注解 \u0026#34;@XxlJob(value=\u0026#34;自定义jobhandler名称\u0026#34;, init = \u0026#34;JobHandler初始化方法\u0026#34;, destroy = \u0026#34;JobHandler销毁方法\u0026#34;)\u0026#34;，注解value值对应的是调度中心新建任务的JobHandler属性的值。 * 3、执行日志：需要通过 \u0026#34;XxlJobHelper.log\u0026#34; 打印执行日志； * 4、任务结果：默认任务结果为 \u0026#34;成功\u0026#34; 状态，不需要主动设置；如有诉求，比如设置任务结果为失败，可以通过 \u0026#34;XxlJobHelper.handleFail/handleSuccess\u0026#34; 自主设置任务结果； * * @author xuxueli 2019-12-11 21:52:51 */ @Component public class SampleXxlJob { private static Logger logger = LoggerFactory.getLogger(SampleXxlJob.class); /** * 1、简单任务示例（Bean模式） */ @XxlJob(\u0026#34;demoJobHandler\u0026#34;) public void demoJobHandler() throws Exception { XxlJobHelper.log(\u0026#34;XXL-JOB, Hello World.\u0026#34;); for (int i = 0; i \u0026lt; 5; i++) { XxlJobHelper.log(\u0026#34;beat at:\u0026#34; + i); TimeUnit.SECONDS.sleep(2); } // default success } /** * 2、分片广播任务 */ @XxlJob(\u0026#34;shardingJobHandler\u0026#34;) public void shardingJobHandler() throws Exception { // 分片参数 int shardIndex = XxlJobHelper.getShardIndex(); int shardTotal = XxlJobHelper.getShardTotal(); XxlJobHelper.log(\u0026#34;分片参数：当前分片序号 = {}, 总分片数 = {}\u0026#34;, shardIndex, shardTotal); // 业务逻辑 for (int i = 0; i \u0026lt; shardTotal; i++) { if (i == shardIndex) { XxlJobHelper.log(\u0026#34;第 {} 片, 命中分片开始处理\u0026#34;, i); } else { XxlJobHelper.log(\u0026#34;第 {} 片, 忽略\u0026#34;, i); } } } /** * 3、命令行任务 */ @XxlJob(\u0026#34;commandJobHandler\u0026#34;) public void commandJobHandler() throws Exception { String command = XxlJobHelper.getJobParam(); int exitValue = -1; BufferedReader bufferedReader = null; try { // command process ProcessBuilder processBuilder = new ProcessBuilder(); processBuilder.command(command); processBuilder.redirectErrorStream(true); Process process = processBuilder.start(); //Process process = Runtime.getRuntime().exec(command); BufferedInputStream bufferedInputStream = new BufferedInputStream(process.getInputStream()); bufferedReader = new BufferedReader(new InputStreamReader(bufferedInputStream)); // command log String line; while ((line = bufferedReader.readLine()) != null) { XxlJobHelper.log(line); } // command exit process.waitFor(); exitValue = process.exitValue(); } catch (Exception e) { XxlJobHelper.log(e); } finally { if (bufferedReader != null) { bufferedReader.close(); } } if (exitValue == 0) { // default success } else { XxlJobHelper.handleFail(\u0026#34;command exit value(\u0026#34;+exitValue+\u0026#34;) is failed\u0026#34;); } } /** * 4、跨平台Http任务 * 参数示例： * \u0026#34;url: http://www.baidu.com\\n\u0026#34; + * \u0026#34;method: get\\n\u0026#34; + * \u0026#34;data: content\\n\u0026#34;; */ @XxlJob(\u0026#34;httpJobHandler\u0026#34;) public void httpJobHandler() throws Exception { // param parse String param = XxlJobHelper.getJobParam(); if (param==null || param.trim().length()==0) { XxlJobHelper.log(\u0026#34;param[\u0026#34;+ param +\u0026#34;] invalid.\u0026#34;); XxlJobHelper.handleFail(); return; } String[] httpParams = param.split(\u0026#34;\\n\u0026#34;); String url = null; String method = null; String data = null; for (String httpParam: httpParams) { if (httpParam.startsWith(\u0026#34;url:\u0026#34;)) { url = httpParam.substring(httpParam.indexOf(\u0026#34;url:\u0026#34;) + 4).trim(); } if (httpParam.startsWith(\u0026#34;method:\u0026#34;)) { method = httpParam.substring(httpParam.indexOf(\u0026#34;method:\u0026#34;) + 7).trim().toUpperCase(); } if (httpParam.startsWith(\u0026#34;data:\u0026#34;)) { data = httpParam.substring(httpParam.indexOf(\u0026#34;data:\u0026#34;) + 5).trim(); } } // param valid if (url==null || url.trim().length()==0) { XxlJobHelper.log(\u0026#34;url[\u0026#34;+ url +\u0026#34;] invalid.\u0026#34;); XxlJobHelper.handleFail(); return; } if (method==null || !Arrays.asList(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;).contains(method)) { XxlJobHelper.log(\u0026#34;method[\u0026#34;+ method +\u0026#34;] invalid.\u0026#34;); XxlJobHelper.handleFail(); return; } boolean isPostMethod = method.equals(\u0026#34;POST\u0026#34;); // request HttpURLConnection connection = null; BufferedReader bufferedReader = null; try { // connection URL realUrl = new URL(url); connection = (HttpURLConnection) realUrl.openConnection(); // connection setting connection.setRequestMethod(method); connection.setDoOutput(isPostMethod); connection.setDoInput(true); connection.setUseCaches(false); connection.setReadTimeout(5 * 1000); connection.setConnectTimeout(3 * 1000); connection.setRequestProperty(\u0026#34;connection\u0026#34;, \u0026#34;Keep-Alive\u0026#34;); connection.setRequestProperty(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json;charset=UTF-8\u0026#34;); connection.setRequestProperty(\u0026#34;Accept-Charset\u0026#34;, \u0026#34;application/json;charset=UTF-8\u0026#34;); // do connection connection.connect(); // data if (isPostMethod \u0026amp;\u0026amp; data!=null \u0026amp;\u0026amp; data.trim().length()\u0026gt;0) { DataOutputStream dataOutputStream = new DataOutputStream(connection.getOutputStream()); dataOutputStream.write(data.getBytes(\u0026#34;UTF-8\u0026#34;)); dataOutputStream.flush(); dataOutputStream.close(); } // valid StatusCode int statusCode = connection.getResponseCode(); if (statusCode != 200) { throw new RuntimeException(\u0026#34;Http Request StatusCode(\u0026#34; + statusCode + \u0026#34;) Invalid.\u0026#34;); } // result bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \u0026#34;UTF-8\u0026#34;)); StringBuilder result = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { result.append(line); } String responseMsg = result.toString(); XxlJobHelper.log(responseMsg); return; } catch (Exception e) { XxlJobHelper.log(e); XxlJobHelper.handleFail(); return; } finally { try { if (bufferedReader != null) { bufferedReader.close(); } if (connection != null) { connection.disconnect(); } } catch (Exception e2) { XxlJobHelper.log(e2); } } } /** * 5、生命周期任务示例：任务初始化与销毁时，支持自定义相关逻辑； */ @XxlJob(value = \u0026#34;demoJobHandler2\u0026#34;, init = \u0026#34;init\u0026#34;, destroy = \u0026#34;destroy\u0026#34;) public void demoJobHandler2() throws Exception { XxlJobHelper.log(\u0026#34;XXL-JOB, Hello World.\u0026#34;); } public void init(){ logger.info(\u0026#34;init\u0026#34;); } public void destroy(){ logger.info(\u0026#34;destroy\u0026#34;); } } 我们现在参考简单示例自己编写代码，在media-service下新建包com.xuecheng.media.service.jobhandler，在该包下定义我们的任务类 JAVA package com.xuecheng.media.service.jobhandler; import com.xxl.job.core.handler.annotation.XxlJob; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; /** * 测试执行器 */ @Slf4j @Component public class SimpleJob { @XxlJob(\u0026#34;testJob\u0026#34;) public void testJob() { log.debug(\u0026#34;开始执行.......\u0026#34;); } } 然后进入调度中心添加任务，进入任务管理，新增任务信息 其中JobHandler中填写@XxlJob注解中的名称 随后启动任务，控制台可以看到执行器的方法执行 ","date":"2024-05-28T15:44:17+08:00","image":"https://www.xuxueli.com/doc/static/xxl-job/images/xxl-logo.jpg","permalink":"http://localhost:1313/p/xxl-job/","title":"Xxl Job"},{"content":"🙃缘起:\r看了大佬博客界面简洁优美 十分羡慕! 于是便花费两年半(天)的时间 ,我也模仿了大佬的博客.\n🎊Hugo博客搭建\r😅在途中我把能踩的坑都踩了 最后还是完成了,果然坚持就是胜利,哈哈哈哈; 在编写这个过程,我发现了我之前破解Typora不能直接打开md文件这个缺点超级明显!! 今天晚上就给删了重新下.\n","date":"2024-05-23T17:24:46+08:00","image":"http://localhost:1313/post/img/wallhaven-o5dj1p.jpg","permalink":"http://localhost:1313/p/%E5%BC%80%E5%A7%8B/","title":"起源"}]